// Generated by CoffeeScript 1.6.2
(function() {
  var define, require,
    _this = this,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  require = this.require;

  define = this.define;

  if (!(define != null ? define.amd : void 0)) {
    require = function(mod) {
      return {
        jquery: _this.jQuery,
        underscore: _this._,
        backbone: _this.Backbone,
        'gallerista/core': _this.gallerista.core,
        'gallerista/utils': _this.gallerista.utils,
        'gallerista/data': _this.gallerista.data
      }[mod];
    };
    define = function() {
      var args, fn, _i, _ref;

      args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), fn = arguments[_i++];
      return ((_ref = _this.gallerista) != null ? _ref : _this.gallerista = {}).carousel = fn(require);
    };
  }

  define(function(require) {
    var $, Backbone, Carousel, Dict, Direction, Orientation, PhotoSlideView, SlideData, SlideDataPool, Units, ViewState, determineNearestDirection, galleristaCore, galleristaData, galleristaUtils, mod, _, _preventDefault, _ref;

    $ = require('jquery');
    _ = require('underscore');
    Backbone = require('backbone');
    galleristaCore = require('gallerista/core');
    galleristaUtils = require('gallerista/utils');
    galleristaData = require('gallerista/data');
    mod = galleristaUtils.mod, Dict = galleristaUtils.Dict, Units = galleristaUtils.Units, Orientation = galleristaUtils.Orientation, Direction = galleristaUtils.Direction, determineNearestDirection = galleristaUtils.determineNearestDirection;
    SlideData = galleristaData.SlideData, SlideDataPool = galleristaData.SlideDataPool;
    ViewState = galleristaCore.ViewState, PhotoSlideView = galleristaCore.PhotoSlideView;
    _preventDefault = function(event) {
      return event.preventDefault();
    };
    Carousel = (function(_super) {
      __extends(Carousel, _super);

      function Carousel() {
        _ref = Carousel.__super__.constructor.apply(this, arguments);
        return _ref;
      }

      Carousel.prototype.Events = {
        POSITION_CHANGE: 'positionChange'
      };

      Carousel.prototype.defaultOptions = {
        direction: Direction.NEAREST,
        orientation: Orientation.HORIZONTAL,
        loop: true,
        slideView: PhotoSlideView,
        viewState: ViewState,
        slides: '> *',
        maxInitialSlideCount: 10,
        gutterSize: 0,
        selectedSlidePosition: '50%',
        dragEnabled: false,
        minDragDistance: 10
      };

      Carousel.prototype.initialize = function() {
        _.defaults(this.options, this.defaultOptions);
        _.bindAll(this, '_clickNextHandler', '_clickPreviousHandler', '_changeSelectedSlideHandler', '_dragStartHandler', '_dragMoveHandler', '_dragEndHandler', '_calcX', '_calcY', '_calcWidth', '_calcHeight', '_modelAtOffset');
        this.currentViewIndex = 0;
        this.window = $(window);
        this.slideDataPool = new SlideDataPool({
          slides: this.model.get('slides'),
          viewState: this.options.viewState,
          slideView: this.options.slideView
        });
        this.viewList = [];
        if (!this.options.loop) {
          throw new Error('Non-looping mode is not yet implemented.');
        }
        if (this.$el.css('position') === 'static') {
          this.$el.css({
            position: 'relative'
          });
        }
        this.initSlideViews();
        this.createSlideContainer();
        this.model.on('change:selectedSlide', this._changeSelectedSlideHandler);
        if (this.options.nextButton) {
          this.$nextButton = $(this.options.nextButton).on('click', this._clickNextHandler);
        }
        if (this.options.previousButton) {
          this.$previousButton = $(this.options.previousButton).on('click', this._clickPreviousHandler);
        }
        this.setupDragging();
        this.updateLayout();
        return this.$el.addClass('initialized');
      };

      Carousel.prototype.getDragOptions = function() {
        var opt, _ref1;

        opt = (_ref1 = this.options.dragEnabled) != null ? _ref1 : false;
        return {
          mouse: opt === true || (opt != null ? opt.mouse : void 0),
          touch: opt === true || (opt != null ? opt.touch : void 0)
        };
      };

      Carousel.prototype.getSlideSize = function(slideModel, data) {
        var $el, aspectRatio, h, height, maxH, maxHeight, maxW, maxWidth, mi, minH, minHeight, minW, minWidth, naturalSize, needToAdd, size, slides, w, width, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;

        if ((_ref1 = this._sizeCache) == null) {
          this._sizeCache = new Dict;
        }
        if ((_ref2 = this._naturalSizes) == null) {
          this._naturalSizes = new Dict;
        }
        size = this._sizeCache.get(slideModel);
        naturalSize = this._naturalSizes.get(slideModel);
        if (size == null) {
          if (data == null) {
            data = _.findWhere(this.viewList, {
              model: slideModel
            });
          }
          if (!data) {
            slides = this.model.get('slides');
            mi = slides.indexOf(slideModel);
            data = (_ref3 = this.slideDataPool.idle[mi]) != null ? _ref3[0] : void 0;
            if (!data) {
              data = this.slideDataPool.add(mi);
              this.validateSize(data);
            }
          }
          if (!naturalSize) {
            $el = data.view.$el;
            needToAdd = !$el.parent().length;
            if (needToAdd) {
              $el.css({
                display: 'block'
              });
              this.appendSlide(data.view);
            }
            naturalSize = (_ref4 = (_ref5 = data.view) != null ? typeof _ref5.getNaturalSize === "function" ? _ref5.getNaturalSize() : void 0 : void 0) != null ? _ref4 : {
              width: $el.outerWidth(true),
              height: $el.outerHeight(true)
            };
            if (needToAdd) {
              $el.css({
                display: 'none'
              });
            }
            this._naturalSizes.set(slideModel, naturalSize);
          }
          size = _.clone(naturalSize);
          if (this.options.slideSize) {
            aspectRatio = naturalSize.width / naturalSize.height;
            _ref6 = this.options.slideSize, minWidth = _ref6.minWidth, maxWidth = _ref6.maxWidth, width = _ref6.width, minHeight = _ref6.minHeight, maxHeight = _ref6.maxHeight, height = _ref6.height;
            if (width != null) {
              w = this.toPx(width);
              if (height == null) {
                h = w / aspectRatio;
              }
            }
            if (height != null) {
              h = this.toPx(height, false);
              if (width == null) {
                w = h * aspectRatio;
              }
            }
            if ((w != null) && (h == null)) {
              h = w / aspectRatio;
            } else if ((h != null) && (w == null)) {
              w = h * aspectRatio;
            } else if ((w == null) && (h == null)) {
              w = naturalSize.width, h = naturalSize.height;
            }
            if (minWidth != null) {
              minW = this.toPx(minWidth);
              if (w < minW) {
                w = minW;
                if (height == null) {
                  h = w / aspectRatio;
                }
              }
            }
            if (minHeight != null) {
              minH = this.toPx(minHeight, false);
              if (h < minH) {
                h = minH;
                if (width == null) {
                  w = h * aspectRatio;
                }
              }
            }
            if (maxWidth != null) {
              maxW = this.toPx(maxWidth);
              if (w > maxW) {
                w = maxW;
                if (height == null) {
                  h = w / aspectRatio;
                }
              }
            }
            if (maxHeight != null) {
              maxH = this.toPx(maxHeight, false);
              if (h > maxH) {
                h = maxH;
                if (width == null) {
                  w = h * aspectRatio;
                }
              }
            }
            size = {
              width: w,
              height: h
            };
          }
          this._sizeCache.set(slideModel, size);
        }
        return {
          width: size.width,
          height: size.height
        };
      };

      Carousel.prototype.appendSlide = function(view) {
        return this.$slideContainer.append(view.$el);
      };

      Carousel.prototype.getSelectedSlidePosition = function() {
        var val;

        val = this.options.selectedSlidePosition;
        if (_.isArray(val)) {
          return [this.parsePosition(val[0]), this.parsePosition(val[1])];
        } else {
          return [this.parsePosition(val), this.parsePosition(val)];
        }
      };

      Carousel.prototype.parsePosition = function(value) {
        var pct;

        if (_.isNumber(value)) {
          return {
            value: value,
            units: Units.PIXELS
          };
        } else if (__indexOf.call(value, '%') >= 0) {
          pct = parseInt(value, 10) / 100;
          return {
            value: pct,
            units: Units.PERCENTAGE
          };
        } else {
          return {
            value: parseInt(value, 10),
            units: Units.PIXELS
          };
        }
      };

      Carousel.prototype.toPx = function(value, horizontal) {
        var m, pos, total;

        if (horizontal == null) {
          horizontal = true;
        }
        pos = this.parsePosition(value);
        if (pos.units === Units.PIXELS) {
          return pos.value;
        } else {
          m = horizontal ? 'innerWidth' : 'innerHeight';
          total = this.$el[m]();
          return pos.value * total;
        }
      };

      Carousel.prototype.fill = function(offset) {
        var available, axis, baseIndex, calcDimension, calcPosition, carouselDimension, containerPosition, d, data, dataList, dir, end, extraAfter, extraBefore, getModelIndex, getViewDimension, i, invalidatePositionOpts, mIndex, maxP, mi, minP, needed, newCurrentIndex, newPA, newPB, placed, pos, position, s, selectedSlideModel, size, slideCount, slides, start, toAppend, toHide, toReposition, toShow, vIndex, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _name, _o, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8,
          _this = this;

        if (offset == null) {
          offset = 0;
        }
        _ref1 = this.options.orientation === Orientation.VERTICAL ? ['y', 'top', this._calcY, this.$el.innerHeight(), this._calcHeight] : ['x', 'left', this._calcX, this.$el.innerWidth(), this._calcWidth], axis = _ref1[0], position = _ref1[1], calcPosition = _ref1[2], carouselDimension = _ref1[3], calcDimension = _ref1[4];
        vIndex = this.currentViewIndex;
        slides = this.model.get('slides');
        selectedSlideModel = this._modelAtOffset(0);
        mIndex = selectedSlideModel ? slides.indexOf(selectedSlideModel) : 0;
        slideCount = slides.length;
        start = vIndex;
        end = start + offset;
        getModelIndex = function(i) {
          return mod(mIndex + i - vIndex, slideCount);
        };
        getViewDimension = function(i) {
          return calcDimension(i - _this.currentViewIndex);
        };
        _ref2 = [Math.min(start, end), Math.max(start, end)], start = _ref2[0], end = _ref2[1];
        pos = this.getSelectedSlidePosition()[axis === 'x' ? 0 : 1];
        _ref3 = pos.units === Units.PIXELS ? [pos.value, carouselDimension - pos.value + getViewDimension(end)] : (d = getViewDimension(end), [pos.value * carouselDimension - pos.value * getViewDimension(start), carouselDimension - (pos.value * carouselDimension - pos.value * d + d)]), extraBefore = _ref3[0], extraAfter = _ref3[1];
        extraBefore += carouselDimension;
        extraAfter += carouselDimension;
        containerPosition = this.$slideContainer.position()[position];
        _ref4 = [-containerPosition, -containerPosition + carouselDimension], minP = _ref4[0], maxP = _ref4[1];
        newPB = calcPosition(start - vIndex) - minP;
        newPA = maxP - (calcPosition(end - vIndex) + calcDimension(end - vIndex));
        extraBefore = Math.max(extraBefore, newPB);
        extraAfter = Math.max(extraAfter, newPA);
        _ref5 = (function() {
          var _i, _len, _ref5, _ref6, _results;

          _ref5 = [[-1, start, extraBefore], [1, end, extraAfter]];
          _results = [];
          for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
            _ref6 = _ref5[_i], dir = _ref6[0], baseIndex = _ref6[1], size = _ref6[2];
            s = 0;
            i = baseIndex;
            while (s < size) {
              i += dir;
              s += getViewDimension(i);
            }
            _results.push(i);
          }
          return _results;
        })(), start = _ref5[0], end = _ref5[1];
        newCurrentIndex = this.currentViewIndex - start;
        placed = {};
        needed = [];
        available = {};
        toAppend = [];
        toShow = [];
        toHide = [];
        toReposition = [];
        for (i = _i = start; start <= end ? _i <= end : _i >= end; i = start <= end ? ++_i : --_i) {
          if ((0 <= i && i < this.viewList.length)) {
            placed[i] = this.viewList[i];
          } else {
            needed.push(i);
          }
        }
        _ref6 = this.viewList;
        for (i = _j = 0, _len = _ref6.length; _j < _len; i = ++_j) {
          data = _ref6[i];
          if (!(__indexOf.call(needed, i) >= 0 || i in placed)) {
            ((_ref7 = available[_name = getModelIndex(i)]) != null ? _ref7 : available[_name] = []).push(data);
          }
        }
        needed = (function() {
          var _k, _len1, _ref8, _results;

          _results = [];
          for (_k = 0, _len1 = needed.length; _k < _len1; _k++) {
            i = needed[_k];
            mi = getModelIndex(i);
            if (data = (_ref8 = available[mi]) != null ? _ref8.pop() : void 0) {
              placed[i] = data;
              toReposition.push(data);
              continue;
            }
            _results.push(i);
          }
          return _results;
        })();
        needed = (function() {
          var _k, _len1, _results;

          _results = [];
          for (_k = 0, _len1 = needed.length; _k < _len1; _k++) {
            i = needed[_k];
            mi = getModelIndex(i);
            if (data = this.slideDataPool.borrow(mi)) {
              placed[i] = data;
              toReposition.push(data);
              toShow.push(data);
              continue;
            }
            _results.push(i);
          }
          return _results;
        }).call(this);
        for (_k = 0, _len1 = needed.length; _k < _len1; _k++) {
          i = needed[_k];
          data = this.slideDataPool.createAndBorrow(getModelIndex(i));
          this.validateSize(data);
          placed[i] = data;
          toAppend.push(data);
          toReposition.push(data);
        }
        for (mi in available) {
          if (!__hasProp.call(available, mi)) continue;
          dataList = available[mi];
          toHide.push.apply(toHide, dataList);
          (_ref8 = this.slideDataPool)["return"].apply(_ref8, dataList);
        }
        invalidatePositionOpts = {};
        invalidatePositionOpts[axis === 'x' ? 'y' : 'x'] = false;
        for (_l = 0, _len2 = toReposition.length; _l < _len2; _l++) {
          data = toReposition[_l];
          data.invalidatePosition(invalidatePositionOpts);
        }
        for (_m = 0, _len3 = toAppend.length; _m < _len3; _m++) {
          data = toAppend[_m];
          this.appendSlide(data.view);
        }
        for (i in placed) {
          if (!__hasProp.call(placed, i)) continue;
          data = placed[i];
          this.validateSize(data);
        }
        for (_n = 0, _len4 = toShow.length; _n < _len4; _n++) {
          data = toShow[_n];
          data.view.$el.css({
            display: 'block'
          });
        }
        for (_o = 0, _len5 = toHide.length; _o < _len5; _o++) {
          data = toHide[_o];
          data.view.$el.css({
            display: 'none'
          });
        }
        this.viewList = (function() {
          var _p, _results;

          _results = [];
          for (i = _p = start; start <= end ? _p <= end : _p >= end; i = start <= end ? ++_p : --_p) {
            _results.push(placed[i]);
          }
          return _results;
        })();
        this.currentViewIndex = newCurrentIndex;
        this.validateSizes();
        return this.validatePositions();
      };

      Carousel.prototype.eachSlide = function(iterator) {
        var data, k, list, _i, _len, _ref1, _ref2, _results;

        _ref1 = this.viewList;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          data = _ref1[_i];
          iterator(data);
        }
        _ref2 = this.slideDataPool.idle;
        _results = [];
        for (k in _ref2) {
          if (!__hasProp.call(_ref2, k)) continue;
          list = _ref2[k];
          _results.push((function() {
            var _j, _len1, _results1;

            _results1 = [];
            for (_j = 0, _len1 = list.length; _j < _len1; _j++) {
              data = list[_j];
              _results1.push(iterator(data));
            }
            return _results1;
          })());
        }
        return _results;
      };

      Carousel.prototype.invalidateSizes = function() {
        this._sizeCache = new Dict;
        return this.eachSlide(function(data) {
          return data.invalidateSize();
        });
      };

      Carousel.prototype.invalidatePositions = function(opts) {
        var _this = this;

        return this.eachSlide(function(data) {
          return data.invalidatePosition(opts);
        });
      };

      Carousel.prototype._modelAtOffset = function(offset) {
        var mIndex, mi, selectedSlideModel, slideCount, slides, vIndex, _ref1;

        vIndex = this.currentViewIndex;
        slides = this.model.get('slides');
        selectedSlideModel = (_ref1 = this.viewList[vIndex]) != null ? _ref1.model : void 0;
        mIndex = selectedSlideModel ? slides.indexOf(selectedSlideModel) : 0;
        slideCount = slides.length;
        mi = mod(mIndex + offset, slideCount);
        return slides.at(mi);
      };

      Carousel.prototype._calcWidth = function(offset) {
        var data, index, slides;

        index = this.currentViewIndex + offset;
        data = this.viewList[index];
        if ((data != null ? data.width : void 0) != null) {
          return data.width;
        } else {
          slides = this.model.get('slides');
          return this.getSlideSize(this._modelAtOffset(offset)).width;
        }
      };

      Carousel.prototype._calcHeight = function(offset) {
        var data, index, slides;

        index = this.currentViewIndex + offset;
        data = this.viewList[index];
        if ((data != null ? data.height : void 0) != null) {
          return data.height;
        } else {
          slides = this.model.get('slides');
          return this.getSlideSize(this._modelAtOffset(offset)).height;
        }
      };

      Carousel.prototype._calcX = function(offset) {
        var calculatedX, data, index, _ref1, _ref2, _ref3;

        index = this.currentViewIndex + offset;
        data = this.viewList[index];
        if ((data != null ? data.calculatedX : void 0) != null) {
          return data != null ? data.calculatedX : void 0;
        }
        calculatedX = offset === 0 ? (_ref1 = data != null ? (_ref2 = data.view) != null ? (_ref3 = _ref2.$el) != null ? _ref3.position().left : void 0 : void 0 : void 0) != null ? _ref1 : 0 : offset < 0 ? this._calcX(offset + 1) - this._calcWidth(offset) - this.options.gutterSize : offset > 0 ? this._calcX(offset - 1) + this._calcWidth(offset - 1) + this.options.gutterSize : void 0;
        if (data != null) {
          data.calculatedX = calculatedX;
        }
        return calculatedX;
      };

      Carousel.prototype._calcY = function(offset) {
        var calculatedY, data, index, _ref1, _ref2, _ref3;

        index = this.currentViewIndex + offset;
        data = this.viewList[index];
        if ((data != null ? data.calculatedY : void 0) != null) {
          return data != null ? data.calculatedY : void 0;
        }
        calculatedY = offset === 0 ? (_ref1 = data != null ? (_ref2 = data.view) != null ? (_ref3 = _ref2.$el) != null ? _ref3.position().top : void 0 : void 0 : void 0) != null ? _ref1 : 0 : offset < 0 ? this._calcY(offset + 1) - this._calcHeight(offset) - this.options.gutterSize : offset > 0 ? this._calcY(offset - 1) + this._calcHeight(offset - 1) + this.options.gutterSize : void 0;
        if (data != null) {
          data.calculatedY = calculatedY;
        }
        return calculatedY;
      };

      Carousel.prototype.validatePositions = function(opts) {
        var axis, calcPosition, data, frame, frameDimension, framePosition, frameSize, i, pos, position, _i, _j, _len, _len1, _ref1, _ref2, _ref3, _results;

        _ref1 = this.options.orientation === Orientation.VERTICAL ? ['y', 'top', this._calcY, 'x', 'left', 'width'] : ['x', 'left', this._calcX, 'y', 'top', 'height'], axis = _ref1[0], position = _ref1[1], calcPosition = _ref1[2], frame = _ref1[3], framePosition = _ref1[4], frameDimension = _ref1[5];
        if ((opts != null ? opts[axis] : void 0) !== false) {
          _ref2 = this.viewList;
          for (i = _i = 0, _len = _ref2.length; _i < _len; i = ++_i) {
            data = _ref2[i];
            if (data[axis] == null) {
              pos = calcPosition(i - this.currentViewIndex);
              data.view.$el.css(position, "" + pos + "px");
              data[axis] = pos;
            }
          }
        }
        if ((opts != null ? opts[frame] : void 0) !== false) {
          pos = null;
          frameSize = null;
          _ref3 = this.viewList;
          _results = [];
          for (i = _j = 0, _len1 = _ref3.length; _j < _len1; i = ++_j) {
            data = _ref3[i];
            if (data[frame] == null) {
              if (data["calculated" + (frame.toUpperCase())] == null) {
                if (pos == null) {
                  pos = this.getSelectedSlidePosition()[frame === 'y' ? 1 : 0];
                }
                data["calculated" + (frame.toUpperCase())] = (function() {
                  switch (pos.units) {
                    case Units.PIXELS:
                      return pos.value;
                    case Units.PERCENTAGE:
                      if (frameSize == null) {
                        frameSize = this.$el[frameDimension === 'height' ? 'innerHeight' : 'innerWidth']();
                      }
                      return pos.value * frameSize - pos.value * data.size[frameDimension];
                  }
                }).call(this);
              }
              data[frame] = data["calculated" + (frame.toUpperCase())];
              _results.push(data.view.$el.css(framePosition, "" + data[frame] + "px"));
            } else {
              _results.push(void 0);
            }
          }
          return _results;
        }
      };

      Carousel.prototype.validateSizes = function(opts) {
        var data, _i, _len, _ref1, _results;

        _ref1 = this.viewList;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          data = _ref1[_i];
          _results.push(this.validateSize(data, opts));
        }
        return _results;
      };

      Carousel.prototype.validateSize = function(data, opts) {
        var $el, force, size, _ref1, _ref2;

        force = opts != null ? opts.force : void 0;
        if (force || (((_ref1 = data.size) != null ? _ref1.width : void 0) == null) || (((_ref2 = data.size) != null ? _ref2.height : void 0) == null)) {
          if (this.options.slideSize) {
            $el = data.view.$el;
            data.size = size = this.getSlideSize(data.model, data);
            if (_.isFunction(data.view.setSize)) {
              data.view.setSize(size.width, size.height);
            } else {
              data.view.$el.width(size.width).height(size.height);
            }
            this.invalidatePositions();
          }
        }
        return data.size || (data.size = this.getSlideSize(data.model, data));
      };

      Carousel.prototype.createSlideContainer = function() {
        var containerHtml, slideEls;

        slideEls = this.$el.children();
        containerHtml = '<div class="galleristacarousel-container"></div>';
        if (slideEls.length) {
          this.$slideContainer = slideEls.wrapAll(containerHtml).parent();
        } else {
          this.$slideContainer = $(containerHtml).appendTo(this.$el);
        }
        return this.$slideContainer.css({
          position: 'absolute'
        });
      };

      Carousel.prototype.initSlideViews = function() {
        var $els;

        $els = this.$el.find(this.options.slides);
        if ($els.length) {
          throw Error('You can\'t have slides in the DOM until I write the code that lets you.');
        }
      };

      Carousel.prototype.gotoNext = function() {
        return this.model.gotoNext(this.options.loop);
      };

      Carousel.prototype.gotoPrevious = function() {
        return this.model.gotoPrevious(this.options.loop);
      };

      Carousel.prototype.getSlideX = function(data) {
        var _ref1;

        return (_ref1 = data.x) != null ? _ref1 : data.x = data.view.$el.position().left;
      };

      Carousel.prototype.getSlideY = function(data) {
        var _ref1;

        return (_ref1 = data.y) != null ? _ref1 : data.y = data.view.$el.position().top;
      };

      Carousel.prototype.getSelectedPosition = function(data) {
        var dimension, innerDimension, pos, slidePos, _ref1;

        _ref1 = this.options.orientation === Orientation.VERTICAL ? [this.getSlideY(data), this.getSelectedSlidePosition()[1], 'height', 'innerHeight'] : [this.getSlideX(data), this.getSelectedSlidePosition()[0], 'width', 'innerWidth'], slidePos = _ref1[0], pos = _ref1[1], dimension = _ref1[2], innerDimension = _ref1[3];
        if (pos.units === Units.PIXELS) {
          return -slidePos + pos.value;
        } else {
          return -slidePos + pos.value * this.$el[innerDimension]() - pos.value * this.getSlideSize(data.model)[dimension];
        }
      };

      Carousel.prototype.determinePath = function(fromIndex, toIndex) {
        var direction, slideCount, targetSlideIndex;

        slideCount = this.model.get('slides').length;
        if (this.options.loop && (this.options.direction === Direction.NEAREST)) {
          direction = determineNearestDirection(fromIndex, toIndex, slideCount);
        } else {
          direction = this.options.direction;
        }
        if (direction === Direction.FORWARD) {
          targetSlideIndex = (toIndex < fromIndex ? toIndex + slideCount : toIndex);
        } else {
          targetSlideIndex = (toIndex > fromIndex ? toIndex - slideCount : toIndex);
        }
        return targetSlideIndex - fromIndex;
      };

      Carousel.prototype.setupDragging = function() {
        var dragOpts;

        dragOpts = this.getDragOptions();
        if (dragOpts.mouse) {
          this.$el.on('mousedown', this._dragStartHandler);
        }
        if (dragOpts.touch) {
          return this.$el.on('touchstart', this._dragStartHandler);
        }
      };

      Carousel.prototype._dragStartHandler = function(event) {
        var axis, currentSlide, dimension, dragOpts, e, startValue, _ref1, _ref2;

        e = event.originalEvent;
        if (e.touches) {
          if (e.touches.length > 1) {
            return;
          }
          e = e.touches[0];
        }
        _ref1 = this.options.orientation === Orientation.VERTICAL ? ['pageY', 'height'] : ['pageX', 'width'], axis = _ref1[0], dimension = _ref1[1];
        currentSlide = this.viewList[this.currentViewIndex];
        startValue = e[axis];
        this._dragState = {
          axis: this.options.orientation === Orientation.VERTICAL ? 'y' : 'x',
          size: this.getSlideSize(currentSlide.model)[dimension],
          position: this.getSelectedPosition(currentSlide),
          startValue: startValue,
          value: startValue,
          startX: e.pageX,
          startY: e.pageY
        };
        if ((_ref2 = this.$document) == null) {
          this.$document = $(document);
        }
        dragOpts = this.getDragOptions();
        if (dragOpts.mouse) {
          this.$document.on('mousemove', this._dragMoveHandler).on('mouseup', this._dragEndHandler);
        }
        if (dragOpts.touch) {
          this.$document.on('touchmove', this._dragMoveHandler).on('touchend touchcancel', this._dragEndHandler);
        }
        if (event.type === 'mousedown') {
          return this.$document.on('selectstart dragstart', _preventDefault);
        }
      };

      Carousel.prototype._dragMoveHandler = function(event) {
        var delta, deltaX, deltaY, e, value;

        e = event.originalEvent;
        if (e.touches) {
          if (e.touches.length > 1) {
            return this._dragEndHandler();
          }
          e = e.touches[0];
        }
        if (!this._dragState.active) {
          deltaX = Math.abs(e.pageX - this._dragState.startX);
          deltaY = Math.abs(e.pageY - this._dragState.startY);
          if (!(deltaX > this.options.minDragDistance || deltaY > this.options.minDragDistance)) {
            return;
          }
          delta = [deltaX, deltaY];
          if (!(this._dragState.active = delta[this._dragState.axis === 'y' ? 'pop' : 'shift']() > delta.pop())) {
            return this._dragEndHandler();
          }
        }
        value = e["page" + (this._dragState.axis.toUpperCase())];
        delta = value - this._dragState.startValue;
        this._dragState.dragDelta = value - this._dragState.value;
        this._dragState.value = value;
        this.updateDrag();
        return event.preventDefault();
      };

      Carousel.prototype._dragEndHandler = function(event) {
        this.$document.off('selectstart dragstart', _preventDefault).off('mousemove touchmove', this._dragMoveHandler).off('mouseup touchend touchcancel', this._dragEndHandler);
        if (this._dragState.active) {
          this.updateDrag(this._dragState.active = false);
          return event != null ? event.preventDefault() : void 0;
        }
      };

      Carousel.prototype.updateDrag = function(active) {
        var autoUpdatePosition, currentPos, delta, dimension, intention, newPos, position, targetPos, _ref1;

        if (active == null) {
          active = this._dragState.active;
        }
        _ref1 = this.options.orientation === Orientation.VERTICAL ? ['height', 'top'] : ['width', 'left'], dimension = _ref1[0], position = _ref1[1];
        currentPos = this.$slideContainer.position()[position];
        delta = currentPos - this._dragState.position;
        intention = this._dragState.dragDelta > 0 ? this.gotoPrevious : this.gotoNext;
        if (intention !== this._dragState.intention) {
          this._dragState.intention = (function() {
            switch (false) {
              case !(delta > 0):
                if (intention === this.gotoPrevious) {
                  return intention;
                } else {
                  return null;
                }
                break;
              case !(delta < 0):
                if (intention === this.gotoNext) {
                  return intention;
                } else {
                  return null;
                }
                break;
              case delta !== 0:
                return intention;
              default:
                return null;
            }
          }).call(this);
        }
        if (!active) {
          if (this._dragState.intention) {
            autoUpdatePosition = this.options.autoUpdatePosition;
            this.options.autoUpdatePosition = false;
            this._dragState.intention.call(this);
            this.options.autoUpdatePosition = autoUpdatePosition;
            targetPos = this.getSelectedPosition(this.viewList[this.currentViewIndex]);
          } else {
            targetPos = this._dragState.position;
          }
        } else if (this._dragState.dragDelta != null) {
          targetPos = this.$slideContainer.position()[position] + this._dragState.dragDelta;
        }
        if (targetPos != null) {
          newPos = targetPos > 0 ? Math.min(this._dragState.position + this._dragState.size + this.options.gutterSize, targetPos) : Math.max(this._dragState.position - this._dragState.size - this.options.gutterSize, targetPos);
          return this.updateDragPosition({
            position: newPos,
            velocity: this._dragState.dragDelta,
            animate: active !== true
          });
        }
      };

      Carousel.prototype.updateDragPosition = function(opts) {
        var currentPosition, delta, duration, pos, posOpts, size, triggerUpdate, _ref1, _ref2, _ref3,
          _this = this;

        pos = this.options.orientation === Orientation.VERTICAL ? 'top' : 'left';
        opts = _.extend({
          target: this.$slideContainer
        }, opts);
        currentPosition = opts.target.position()[pos];
        delta = opts.position - currentPosition;
        if (delta === 0) {
          return;
        }
        triggerUpdate = ((_ref1 = this._events) != null ? (_ref2 = _ref1[this.Events.POSITION_CHANGE]) != null ? _ref2.length : void 0 : void 0) > 0;
        if (opts.animate !== false) {
          size = this._dragState.size;
          duration = (_ref3 = opts.duration) != null ? _ref3 : 400;
          duration = Math.max(duration / 2, Math.min(duration, Math.abs(delta) / size * duration));
          duration = Math.min(duration, size / Math.abs(opts.velocity || 1) * $.fx.interval);
          return opts.target.stop(true).css({
            __value: 0
          }).animate({
            __value: 1
          }, {
            duration: duration,
            easing: 'linear',
            step: function(now) {
              var posOpts;

              posOpts = {};
              posOpts[pos] = delta * Math.sqrt(1 - (now = now - 1) * now) + currentPosition;
              opts.target.css(posOpts);
              if (triggerUpdate) {
                return _this.trigger(_this.Events.POSITION_CHANGE, posOpts);
              }
            }
          });
        } else {
          posOpts = {};
          posOpts[pos] = opts.position;
          opts.target.stop(true, true).css(posOpts);
          if (triggerUpdate) {
            return this.trigger(this.Events.POSITION_CHANGE, posOpts);
          }
        }
      };

      Carousel.prototype.updateSelected = function(opts) {
        var modelIndex, newSelectedSlideData, offset, oldSelectedSlideData, previousModelIndex, targetPos;

        previousModelIndex = this._previousModelIndex;
        modelIndex = this.model.get('selectedSlideIndex');
        if (!((opts != null ? opts.force : void 0) || modelIndex !== previousModelIndex)) {
          return;
        }
        oldSelectedSlideData = this.viewList[this.currentViewIndex];
        offset = this.determinePath(previousModelIndex || 0, modelIndex);
        this.fill(offset);
        this.currentViewIndex += offset;
        newSelectedSlideData = this.viewList[this.currentViewIndex];
        if (oldSelectedSlideData != null) {
          oldSelectedSlideData.viewState.set({
            selected: false
          });
        }
        newSelectedSlideData.viewState.set({
          selected: true
        });
        targetPos = this.getSelectedPosition(newSelectedSlideData);
        if (this.options.autoUpdatePosition !== false) {
          this.updatePosition({
            position: targetPos,
            animate: (opts != null ? opts.animate : void 0) !== false
          });
        }
        return this._previousModelIndex = modelIndex;
      };

      Carousel.prototype.updateLayout = function(opts) {
        if ((opts != null ? opts.resize : void 0) !== false) {
          this.invalidateSizes();
        }
        return this.updateSelected({
          force: true,
          animate: false
        });
      };

      Carousel.prototype.updatePosition = function(opts) {
        var animOpts, event, pos, posOpts, stepFn, trigger, triggerUpdate, _ref1, _ref2;

        pos = this.options.orientation === Orientation.VERTICAL ? 'top' : 'left';
        opts = _.extend({
          target: this.$slideContainer
        }, this.options.animation, opts);
        posOpts = {};
        posOpts[pos] = opts.position;
        triggerUpdate = ((_ref1 = this._events) != null ? (_ref2 = _ref1[this.Events.POSITION_CHANGE]) != null ? _ref2.length : void 0 : void 0) > 0;
        if (opts.animate !== false) {
          animOpts = _.omit(opts, 'animate', 'target', 'position');
          if (triggerUpdate) {
            stepFn = animOpts.step;
            trigger = this.trigger;
            event = this.Events.POSITION_CHANGE;
            animOpts.step = function(now) {
              var stepPosOpts;

              stepPosOpts = {};
              stepPosOpts[pos] = now;
              trigger(event, stepPosOpts);
              return stepFn != null ? stepFn.apply(this, arguments) : void 0;
            };
          }
          return opts.target.stop(true).animate(posOpts, animOpts);
        } else {
          opts.target.stop(true, true).css(posOpts);
          if (triggerUpdate) {
            return this.trigger(this.Events.POSITION_CHANGE, posOpts);
          }
        }
      };

      Carousel.prototype._changeSelectedSlideHandler = function(model, slide, options) {
        return this.updateSelected();
      };

      Carousel.prototype._clickNextHandler = function(event) {
        event.preventDefault();
        return this.gotoNext();
      };

      Carousel.prototype._clickPreviousHandler = function(event) {
        event.preventDefault();
        return this.gotoPrevious();
      };

      return Carousel;

    })(Backbone.View);
    return _.extend({
      Carousel: Carousel
    }, galleristaCore);
  });

}).call(this);
